# 🧭 AI 기반 웹 서비스 프로젝트 지침 (PRD~API Spec 통합)

이 문서는 AI Agent(예: Claude)가 웹 서비스의 **기획 → 설계 → 개발 명세**를 일관성 있게 작성할 수 있도록 하는 표준 지침이다.  
각 섹션은 제품 기획(PRD), 기능 명세(FSD), UI 설계, DB Schema, API Spec 작성 시 반드시 준수해야 하는 원칙을 포함한다.

---

## 🧾 PRD(제품 요구사항 문서) 지침

### 목적
PRD(Product Requirement Document)는 제품의 목적과 사용 시나리오, 기능 요구사항을 명확히 정의하기 위한 문서이다.  
Claude는 사용자의 니즈와 비즈니스 목표를 기준으로 핵심 기능을 제안하고, 기능 우선순위를 명확히 구분해야 한다.

---

### 문서 구성

#### 1. 개요
- 서비스 요약 및 문제 정의  
- 대상 사용자(Persona)  
- 주요 가치 제안 (Value Proposition)

#### 2. 목표 및 KPI
- 제품이 해결해야 할 핵심 문제  
- 주요 성과 지표(KPI) 정의 (예: 전환율, 재방문율 등)

#### 3. 기능 요구사항
- 기능별 이름 및 설명  
- 사용자 시나리오 (User Flow 포함)  
- 입력/출력 데이터 명세  
- 성공 및 실패 조건  
- 엣지 케이스 고려사항

#### 4. 기능 우선순위
1️⃣ MVP 필수 기능  
2️⃣ 확장 기능  
3️⃣ 부가 기능  

#### 5. 비기능 요구사항
- 성능 목표 (로딩 속도, 반응성 등)  
- 접근성 및 보안 기준  
- 브라우저/디바이스 호환성  

---

## ⚙️ FSD(기능 명세서) 지침

### 목적
FSD(Functional Specification Document)는 기능별 구체적인 동작 방식, 로직, 데이터 흐름을 정의한다.  
Claude는 PRD의 요구사항을 기반으로 실제 시스템 구현에 필요한 명세를 상세히 기술해야 한다.

---

### 문서 구성

#### 1. 기능 구조
- 전체 기능 트리 구조 (Feature Map)
- 각 기능의 관계 및 종속성

#### 2. 기능 상세 명세
- 기능명  
- 트리거 조건 (예: 버튼 클릭, API 호출 등)  
- 처리 로직 (입력 → 처리 → 출력 단계)  
- 예외 및 오류 처리 규칙  
- 상태 변화 (State Transition)

#### 3. 데이터 흐름
- 프론트엔드 ↔ 백엔드 간 데이터 플로우  
- 입력/응답 데이터 구조(JSON 예시 포함)

#### 4. UI 연계
- 기능이 연결된 UI 컴포넌트명  
- 주요 상호작용 시나리오 (Interaction Flow)

#### 5. 테스트 조건
- 성공/실패 테스트 케이스  
- 경계 조건 테스트 (Edge Case)

---

## 🎨 UI 설계 지침

### 목적
UI 설계 문서는 사용자가 서비스를 직관적으로 이용할 수 있도록 시각적, 구조적 요소를 정의한다.  
Claude는 제품 철학, UX 원칙, 접근성 기준을 반영해 UI 구조를 설계해야 한다.

---

### 문서 구성

#### 1. 정보 구조 (IA)
- 페이지 트리 구조 정의 (홈 → 세부 페이지 → 기능 단위)  
- 각 페이지의 역할과 목적

#### 2. 화면 구성 요소
- 기본 레이아웃 정의 (Header, Sidebar, Main, Footer 등)  
- 주요 UI 컴포넌트 리스트 (Button, Modal, Table 등)

#### 3. 디자인 시스템
- 기본 색상 팔레트 (Primary, Secondary, Error 등)  
- 폰트 스타일 및 크기 규칙  
- Spacing 단위 (8px grid 등)  
- 반응형 기준 (Mobile, Tablet, Desktop)

#### 4. 접근성 및 UX 가이드
- 명확한 시각 대비  
- 키보드 내비게이션 지원  
- 피드백 및 에러 메시지 규칙  
- 일관된 상호작용 패턴

#### 5. 시각적 일관성
- 동일한 컴포넌트는 동일한 스타일 유지  
- 브랜딩 톤앤매너(친근함, 신뢰감 등) 반영  

---

## 🗃️ DB Schema 설계 지침

### 목적
DB Schema 문서는 서비스의 데이터 구조를 명확히 정의하고, 엔티티 간 관계를 설계하기 위한 기준이다.  
Claude는 데이터 무결성, 확장성, 정규화 원칙을 고려하여 DB 구조를 제안해야 한다.

---

### 문서 구성

#### 1. 설계 원칙
- 정규화 우선 (3NF 기준), 단 성능상 필요한 경우 비정규화 예외 허용  
- PK는 `uuid` 또는 `id` auto increment 방식 명시  
- Naming Rule: snake_case 사용  
- 외래키 및 관계 정의 (1:N, N:N 등)

#### 2. 엔티티 정의
각 테이블(엔티티)별로 다음 항목을 포함:
- 테이블명  
- 주요 컬럼명, 데이터 타입, 제약조건  
- 기본키 및 인덱스 정의  
- 관계(Relation) 및 참조키

#### 3. ERD 구조
- 엔티티 간 관계 다이어그램 명시  
- 상위 → 하위 의존 관계 표시  

#### 4. 데이터 예시
- 샘플 레코드(JSON 또는 SQL INSERT 형태) 포함  

---

# 🔗 API Spec 설계 지침

## 목적
API Spec은 클라이언트와 서버 간의 통신 규격을 명확히 정의하기 위한 문서이다.  
Claude는 RESTful 또는 GraphQL 설계 원칙을 기반으로, 일관된 데이터 구조, 에러 처리, 인증 로직을 포함한 안정적인 API 명세를 생성해야 한다.

---

## 문서 구성

### 1. 기본 규칙
- API는 RESTful 원칙을 준수한다.  
- HTTP Method의 역할을 명확히 구분한다.  
  - GET: 데이터 조회  
  - POST: 데이터 생성  
  - PUT/PATCH: 데이터 수정  
  - DELETE: 데이터 삭제  
- 엔드포인트는 **kebab-case** 또는 **소문자 복수형**으로 작성한다.  
  - 예: `/api/v1/users`, `/api/v1/user-profiles`  
- 모든 응답은 JSON 형식으로 통일한다.

---

### 2. 요청(Request) 명세
- **Method**: 요청에 사용되는 HTTP 메서드  
- **Endpoint**: `/api/v1/...` 형태의 URI  
- **Headers**: Authorization, Content-Type 등 명시  
- **Parameters / Body 구조**: 요청 필드, 타입, 필수 여부  
- **Validation 규칙**: 유효성 검증 조건 명시  

#### 예시
```json
POST /api/v1/users
{
  "email": "string (required)",
  "password": "string (required, minLength:8)"
}
```

---

### 3. 응답(Response) 명세
- 모든 응답은 공통 구조를 따른다.

**공통 응답 포맷**
```json
{
  "status": "success",
  "message": "optional",
  "data": {}
}
```

**성공 응답 예시**
```json
{
  "status": "success",
  "message": "User created successfully",
  "data": {
    "id": "uuid",
    "email": "user@example.com"
  }
}
```

**실패 응답 예시**
```json
{
  "status": "error",
  "message": "Invalid credentials",
  "code": 401
}
```

---

### 4. 에러 처리(Error Handling)
- 공통 에러 코드 테이블을 정의한다.

| HTTP 코드 | 상태                   | 설명                       |
|-----------|------------------------|----------------------------|
| 200       | OK                     | 요청 성공                  |
| 201       | Created                | 데이터 생성 성공           |
| 400       | Bad Request            | 잘못된 요청                |
| 401       | Unauthorized           | 인증 실패                  |
| 403       | Forbidden              | 접근 권한 없음             |
| 404       | Not Found              | 리소스 없음                |
| 409       | Conflict               | 중복 데이터 등 충돌        |
| 422       | Unprocessable Entity   | 검증 실패                  |
| 500       | Internal Server Error  | 서버 내부 오류             |

**에러 응답 구조 예시**
```json
{
  "status": "error",
  "message": "Invalid request data",
  "code": 422,
  "details": {
    "email": "This field is required"
  }
}
```

**에러 처리 규칙**
- Validation 실패 시 422 사용
- 인증 관련 문제는 401 / 403 구분
- 서버 내부 오류는 사용자 친화적인 메시지로 처리

---

### 5. 인증 및 보안(Authentication & Security)
- 기본 인증 방식: JWT (JSON Web Token) 사용
- Authorization: Bearer <token> 헤더 포함
- 토큰에는 사용자 ID 및 권한 정보를 포함
- 토큰 만료 처리
- Access Token: 짧은 수명 (예: 1시간)
- Refresh Token: 장기 수명 (예: 7일)
- Refresh Token은 /api/v1/auth/refresh 엔드포인트로 갱신
- 역할 기반 접근 제어(Role-based Access Control)
- 예: admin, user, guest
- 보안 정책
- HTTPS 통신 필수
- CORS 정책 명시 (허용 origin, method 등)
- Rate Limiting 적용 기준 설정

---

### 6. 버전 관리(API Versioning)
- 버전 명시 규칙: /api/v1/ 형식으로 명시
- 버전 변경 시 고려사항
- 기존 버전 호환성 유지 (deprecation 기간 제공)
- 주요 변경사항은 CHANGELOG.md에 기록
- 버전 간 차이점 명시 (필드명 변경, 응답 구조 수정 등)

**예시**

/api/v1/users  → 기존 버전
/api/v2/users  → 개선된 필드, 성능 최적화 등

**버전 관리 원칙**
- Breaking change 발생 시 반드시 새로운 버전 생성
- Minor update는 동일 버전 내 문서 갱신으로 처리

---

### 7. 문서화
- API 문서는 OpenAPI 3.0 (Swagger) 형식으로 자동화 가능
- 각 엔드포인트에 요청/응답 예시 포함
- 변경 시 version, date, author 메타데이터 기록

---

### ✅ 최종 출력 형식 예시

Claude가 생성할 API Spec은 아래와 같은 구조로 작성한다.

```json
{
  "method": "POST",
  "endpoint": "/api/v1/users",
  "description": "새로운 사용자 계정 생성",
  "request": {
    "headers": { "Authorization": "Bearer token" },
    "body": { "email": "string", "password": "string" }
  },
  "response": {
    "status": "success",
    "message": "User created",
    "data": { "id": "uuid" }
  },
  "errors": [
    { "code": 400, "message": "Invalid email format" },
    { "code": 409, "message": "Email already exists" }
  ]
}
```